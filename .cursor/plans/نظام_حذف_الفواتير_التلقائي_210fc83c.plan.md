---
name: نظام حذف الفواتير التلقائي
overview: "إنشاء نظام حذف تلقائي للفواتير القديمة يعمل مع أول استخدام في اليوم، مع تحديد مدة الاحتفاظ بناءً على نوع الفاتورة (هاتف: 365 يوم، إكسسوارات/قطع غيار: 90 يوم)"
todos: []
---

#نظام حذف الفواتير القديمة التلقائي

## نظرة عامة

نظام يفحص الفواتير المخزنة ويحذف الفواتير القديمة تلقائياً بناءً على نوع المنتجات فيها، مع تشغيله مرة واحدة يومياً عند أول طلب API.

## متطلبات النظام

### مدة الاحتفاظ حسب نوع الفاتورة:

- **فاتورة تحتوي على هاتف (phone)**: 365 يوم
- **فاتورة تحتوي على إكسسوارات فقط (accessory)**: 90 يوم  
- **فاتورة تحتوي على قطع غيار فقط (spare_part)**: 90 يوم
- **فاتورة مختلطة (هاتف + آخر)**: 365 يوم (أطول مدة)
- **فاتورة مختلطة (إكسسوارات + قطع غيار فقط)**: 90 يوم

### آلية التشغيل:

- يتم استدعاء cleanup مع أول طلب API في اليوم (في `config.php` عند تهيئة النظام)
- يتم تنفيذ cleanup **بعد إرسال الاستجابة** (async) لضمان عدم التأثير على المستخدم
- يتم استخدام ملف JSON في `data/` لتتبع آخر تاريخ cleanup

## الملفات المطلوبة

### 1. ملف API جديد: `api/invoice-cleanup.php`

- دوال إدارة cleanup للفواتير
- تحديد نوع الفاتورة من جدول `sale_items` (item_type)
- حساب مدة الاحتفاظ بناءً على الأنواع الموجودة
- حذف ملفات الفواتير القديمة

**الدوال الرئيسية:**

- `getInvoiceCleanupSettings()` - جلب الإعدادات من ملف JSON
- `updateInvoiceCleanupSettings()` - حفظ الإعدادات
- `getInvoiceRetentionDays($saleId)` - تحديد مدة الاحتفاظ للفاتورة بناءً على أنواع المنتجات
- `shouldRunCleanupToday()` - التحقق إذا كان يجب تشغيل cleanup اليوم
- `performInvoiceCleanup()` - تنفيذ عملية الحذف

**المنطق:**

- جلب الفواتير من `sales` مع عناصرها من `sale_items`
- لكل فاتورة، تحديد الأنواع الموجودة (phone, accessory, spare_part)
- حساب مدة الاحتفاظ: إذا كان يوجد phone → 365 يوم، وإلا → 90 يوم
- حذف الملفات التي مضى عليها أكثر من المدة المحددة

### 2. تعديل `api/config.php`

- إضافة استدعاء cleanup عند تهيئة النظام (مع أول طلب في اليوم)
- استخدام `register_shutdown_function()` لتنفيذ cleanup بعد إرسال الاستجابة
- إضافة require لملف `invoice-cleanup.php`

**الكود المطلوب:**

- في دالة `initializeSystem()`: استدعاء `scheduleInvoiceCleanupIfNeeded()`
- دالة `scheduleInvoiceCleanupIfNeeded()`: التحقق من الحاجة وتحديد cleanup للتنفيذ لاحقاً

### 3. ملف إعدادات: `data/invoice-cleanup-settings.json`

- حفظ آخر تاريخ cleanup
- إعدادات النظام (مفعّل/معطّل، حجم الدفعة، إلخ)

**البنية:**

```json
{
  "enabled": true,
  "last_cleanup_date": "2025-01-15",
  "batch_size": 50,
  "max_execution_time": 30,
  "total_deleted": 0,
  "last_run_stats": null
}
```



## تفاصيل التنفيذ

### تحديد نوع الفاتورة

- جلب `sale_items` لكل فاتورة من قاعدة البيانات
- التحقق من `item_type` في كل عنصر
- تحديد الأنواع الموجودة: phone, accessory, spare_part

### حساب مدة الاحتفاظ

```php
function getInvoiceRetentionDays($saleId) {
    // جلب عناصر الفاتورة
    $items = dbSelect("SELECT item_type FROM sale_items WHERE sale_id = ?", [$saleId]);
    
    $hasPhone = false;
    $hasAccessory = false;
    $hasSparePart = false;
    
    foreach ($items as $item) {
        if ($item['item_type'] === 'phone') $hasPhone = true;
        if ($item['item_type'] === 'accessory') $hasAccessory = true;
        if ($item['item_type'] === 'spare_part') $hasSparePart = true;
    }
    
    // إذا كان يوجد هاتف → 365 يوم
    if ($hasPhone) return 365;
    
    // وإلا → 90 يوم
    return 90;
}
```



### عملية الحذف

- استخدام جدول `sales` مع JOIN على `sale_items` لتحديد الفواتير القديمة
- لكل فاتورة قديمة، حساب مدة الاحتفاظ المخصصة
- حذف الملفات من مجلد `invoices/` باستخدام `deleteInvoiceFile()` الموجود
- تحديث ملف الإعدادات بتاريخ آخر cleanup

### الحماية من التكرار

- التحقق من `last_cleanup_date` في ملف الإعدادات
- إذا كان آخر cleanup اليوم → لا تقم بتنفيذ cleanup مرة أخرى
- استخدام `register_shutdown_function()` لضمان عدم التأثير على الاستجابة

## الأداء والكفاءة

- **استخدام قاعدة البيانات**: البحث من `sales` و `sale_items` أسرع من قراءة الملفات
- **Batch Processing**: معالجة دفعات صغيرة (50 فاتورة) لتجنب الضغط
- **Async Execution**: التنفيذ بعد إرسال الاستجابة لا يؤثر على المستخدم
- **Time Limit**: حد أقصى لوقت التنفيذ (30 ثانية) لحماية السيرفر
- **مرة واحدة يومياً**: توفير الموارد وعدم الضغط على السيرفر

## الأمان والاستقرار

- التحقق من وجود الملفات قبل الحذف
- معالجة الأخطاء بدون توقف النظام